        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="pt-BR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="j3ItBUzOAidvszQLYMDVlNLsgyganvlzEKSqN4nwXBw=" PayloadSize="10209" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-PowerShell-ISE-FOD-Package~31bf3856ad364e35~wow64~pt-br~.cab" PayloadType="ExpressCab" />
        <PayloadItem PayloadHash="Tsa2RcOYH1XjIAvF/a5CNXWIAGP1+Ulo/6gkWltYm6o=" PayloadSize="69043" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-PowerShell-ISE-FOD-Package~31bf3856ad364e35~wow64~pt-br~.psf" PayloadType="ExpressPSF" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-Printing-PMCPPC-FoD-Package~31bf3856ad364e35~amd64~pt-br~" InstalledSize="227790" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="pt-BR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="Qstn1eoXtSaqAnCk2KKYuA/s7t97VfYvqxw4xBRD1uE=" PayloadSize="10271" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-Printing-PMCPPC-FoD-Package~31bf3856ad364e35~amd64~pt-br~.cab" PayloadType="ExpressCab" />
        <PayloadItem PayloadHash="VK41fMeS1earHfiicVOO3IcALozx1cYLZWGiuvRgLas=" PayloadSize="80670" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-Printing-PMCPPC-FoD-Package~31bf3856ad364e35~amd64~pt-br~.psf" PayloadType="ExpressPSF" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-Printing-WFS-FoD-Package~31bf3856ad364e35~amd64~pt-br~" InstalledSize="551138" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="pt-BR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="py+/hp3Gcd3V+Bkm+mU5PxLjP9MHqYpcGC9psRCm9Go=" PayloadSize="11351" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-Printing-WFS-FoD-Package~31bf3856ad364e35~amd64~pt-br~.cab" PayloadType="ExpressCab" />
        <PayloadItem PayloadHash="wAqTT2nXw1MmStCTS206RILNvrkgUij1zMrV75s4aGc=" PayloadSize="191436" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-Printing-WFS-FoD-Package~31bf3856ad364e35~amd64~pt-br~.psf" PayloadType="ExpressPSF" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-RasCMAK-Client-Package~31bf3856ad364e35~amd64~pt-br~" InstalledSize="233417" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="pt-BR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="bxdmwOvOSz83lOj6pNJEO8x/4E0viqTprHNfWDBhSRk=" PayloadSize="10481" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-RasCMAK-Client-Package~31bf3856ad364e35~amd64~pt-br~.cab" PayloadType="ExpressCab" />
        <PayloadItem PayloadHash="5ZT0Wm1uOTnBtNBebJj3Zqt0AxNOU9oZphbX+cw1mgY=" PayloadSize="116875" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-RasCMAK-Client-Package~31bf3856ad364e35~amd64~pt-br~.psf" PayloadType="ExpressPSF" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-RasCMAK-Client-Package~31bf3856ad364e35~wow64~pt-br~" InstalledSize="404269" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="pt-BR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="DBUZd5eFmtmr+rfJ3AAjk7oBk09b1jI0Ud4Rr6y8lZY=" PayloadSize="10585" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-RasCMAK-Client-Package~31bf3856ad364e35~wow64~pt-br~.cab" PayloadType="ExpressCab" />
        <PayloadItem PayloadHash="iXFFiAE1Bpeylk1LC+EL8BO+xNiS+SJ2ZF52UhBG7QA=" PayloadSize="319663" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-RasCMAK-Client-Package~31bf3856ad364e35~wow64~pt-br~.psf" PayloadType="ExpressPSF" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-RasRip-Package~31bf3856ad364e35~amd64~pt-br~" InstalledSize="26239" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="pt-BR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="sPVbCYUjPduJO8wEDgMzkbeA67+2xx5cLWnzD/mvQR0=" PayloadSize="10013" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-RasRip-Package~31bf3856ad364e35~amd64~pt-br~.cab" PayloadType="ExpressCab" />
        <PayloadItem PayloadHash="PS/K6cRS8MVmTrTSMw3VwL/Aa6ttgQlYYWRU0RRQdgE=" PayloadSize="52917" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-RasRip-Package~31bf3856ad364e35~amd64~pt-br~.psf" PayloadType="ExpressPSF" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-RemoteAccess-Management-Tools-FoD-Package~31bf3856ad364e35~amd64~pt-br~" InstalledSize="18674950" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="pt-BR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="O33dU4IT7NwCymucL4KqPFP821/xRO8Lg2i9eVgUaA4=" PayloadSize="12177" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-RemoteAccess-Management-Tools-FoD-Package~31bf3856ad364e35~amd64~pt-br~.cab" PayloadType="ExpressCab" />
        <PayloadItem PayloadHash="l8bT2irxyDoMSAfPfkfdicWjJdUlvYX9KaPlauRDGOQ=" PayloadSize="3391003" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-RemoteAccess-Management-Tools-FoD-Package~31bf3856ad364e35~amd64~pt-br~.psf" PayloadType="ExpressPSF" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-RemoteAccess-Management-Tools-FoD-Package~31bf3856ad364e35~wow64~pt-br~" InstalledSize="12623" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="arch" Value="wow64" />
          <ApplyTo Type="language" Value="pt-BR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="4Jikxd+EbPXzNkngyiOQYWi2YHRFhPxNvbR04Cw5a7w=" PayloadSize="10103" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-RemoteAccess-Management-Tools-FoD-Package~31bf3856ad364e35~wow64~pt-br~.cab" PayloadType="ExpressCab" />
        <PayloadItem PayloadHash="eABsOeRsd22Y4lCsvpVFbBAsYSFS4LL5i63HVqAf+GE=" PayloadSize="49918" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-RemoteAccess-Management-Tools-FoD-Package~31bf3856ad364e35~wow64~pt-br~.psf" PayloadType="ExpressPSF" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-RemoteDesktop-Services-Tools-FoD-Package~31bf3856ad364e35~amd64~pt-br~" InstalledSize="1531944" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="pt-BR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="4lZFF/pI+9bTWHRtZiqrp1pU5Sv6jzq2OL6/PGw9o5Y=" PayloadSize="11875" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-RemoteDesktop-Services-Tools-FoD-Package~31bf3856ad364e35~amd64~pt-br~.cab" PayloadType="ExpressCab" />
        <PayloadItem PayloadHash="eGy1o4aQJKvMM3YEPX87/AdUmCJUl7U8o2L4CK0PjSo=" PayloadSize="293705" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-RemoteDesktop-Services-Tools-FoD-Package~31bf3856ad364e35~amd64~pt-br~.psf" PayloadType="ExpressPSF" />
      </Payload>
    </Package>
    <Package ID="Microsoft-Windows-Server-AppCompat-FoD-Package~31bf3856ad364e35~amd64~pt-br~" InstalledSize="29594448" Version="10.0.19041.1">
      <SatelliteInfo>
        <ApplyToInfo>
          <ApplyTo Type="language" Value="pt-BR" />
        </ApplyToInfo>
      </SatelliteInfo>
      <Payload>
        <PayloadItem PayloadHash="2FLnRnG1FL3u+P2ngQYt+kVN8ciPg4a/3SOXIyM+bqg=" PayloadSize="72653" Path="FeaturesOnDemand\pt-br\baseless\Microsoft-Windows-Server-AppCompat-FoD-Package~31bf3856ad364e35~amd64~pt-br~.cab" PayloadType="ExpressCab" />
        <PayloadItem PayloadHash="a1jj/+6mLdvmfJ7rsq2TVROt1vzBCeqnKYcW+ERMae8=error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atNextItem = !this.onKeyLine &&
                this.indent === map.indent &&
                it.sep &&
                this.type !== 'seq-item-ind';
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {
                        it.start.push(this.sourceToken);
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken] }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (includesToken(it.start, 'explicit-key-ind')) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key, delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (atNextItem &&
                            bv.type !== 'block-seq' &&
                            includesToken(it.start, 'explicit-key-ind')) {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

export { Parser };
